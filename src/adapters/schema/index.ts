import { Model, Schema } from 'mongoose'
import { SchemaAdapter, SchemaType } from '../../types'
import { MongooseAdapter } from './MongooseAdapter'
import { TypegooseAdapter, TypegooseAdapterOptions } from './TypegooseAdapter'

/**
 * Check if a class has Typegoose metadata
 */
function isTypegooseClass(schema: any): boolean {
  if (typeof schema !== 'function' || !schema.prototype) {
    return false
  }

  // Check for Typegoose metadata via Reflect (added by reflect-metadata polyfill)
  const R = Reflect as any
  if (typeof R.getMetadata === 'function') {
    const props = R.getMetadata('typegoose:properties', schema.prototype)
    if (props) {
      return true
    }
  }

  // Fallback: check for common Typegoose static/prototype markers
  // Typegoose classes often have a schema generated by getModelForClass
  // but before that, they may not have .schema â€” so we rely on metadata above
  return false
}

/**
 * Detect the type of schema provided
 */
export function detectSchemaType(schema: any): SchemaType {
  if (schema instanceof Schema) {
    return SchemaType.Mongoose
  }

  if (typeof schema === 'function' && schema.prototype && schema.schema) {
    return SchemaType.Mongoose
  }

  if (isTypegooseClass(schema)) {
    return SchemaType.Typegoose
  }

  return SchemaType.Unknown
}

/**
 * Create appropriate schema adapter based on schema type
 */
export function createSchemaAdapter(
  schema: Schema | Model<any> | any,
  options?: TypegooseAdapterOptions
): SchemaAdapter {
  const schemaType = detectSchemaType(schema)

  if (schemaType === SchemaType.Mongoose) {
    return new MongooseAdapter(schema)
  }

  if (schemaType === SchemaType.Typegoose) {
    return new TypegooseAdapter(schema, options)
  }

  throw new Error(`Unsupported schema type: ${schemaType}`)
}

// Re-export adapters
export { MongooseAdapter }
export { TypegooseAdapter }
export type { TypegooseAdapterOptions }
